type=page
status=published
title=The producerfields Example: Using Producer Fields to Generate Resources
next=cdi-adv-examples005.html
prev=cdi-adv-examples003.html
~~~~~~
= The producerfields Example: Using Producer Fields to Generate Resources


[[GKHRG]]

[[the-producerfields-example-using-producer-fields-to-generate-resources]]
The producerfields Example: Using Producer Fields to Generate Resources
-----------------------------------------------------------------------

The `producerfields` example, which allows you to create a to-do list,
shows how to use a producer field to generate objects that can then be
managed by the container. This example generates an `EntityManager`
object, but resources such as JDBC connections and datasources can also
be generated this way.

The `producerfields` example is the simplest possible entity example. It
also contains a qualifier and a class that generates the entity manager.
It also contains a single entity, a stateful session bean, a Facelets
page, and a managed bean.

The source files are located in the
`_tut-install_/examples/cdi/producerfields/src/main/java/javaeetutorial/producerfields/`
directory.

The following topics are addressed here:

* link:#GKHPP[The Producer Field for the producerfields Example]
* link:#GKHPD[The producerfields Entity and Session Bean]
* link:#GKHPF[The producerfields Facelets Pages and Managed Bean]
* link:#GKHRH[Running the producerfields Example]

[[GKHPP]]

[[the-producer-field-for-the-producerfields-example]]
The Producer Field for the producerfields Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The most important component of the `producerfields` example is the
smallest, the `db.UserDatabaseEntityManager` class, which isolates the
generation of the `EntityManager` object so it can easily be used by
other components in the application. The class uses a producer field to
inject an `EntityManager` annotated with the `@UserDatabase` qualifier,
also defined in the `db` package:

[source,oac_no_warn]
----
@Singleton
public class UserDatabaseEntityManager {

    @Produces
    @PersistenceContext
    @UserDatabase
    private EntityManager em;
    ...
}
----

The class does not explicitly produce a persistence unit field, but the
application has a `persistence.xml` file that specifies a persistence
unit. The class is annotated `javax.inject.Singleton` to specify that
the injector should instantiate it only once.

The `db.UserDatabaseEntityManager` class also contains commented-out
code that uses `create` and `close` methods to generate and remove the
producer field:

[source,oac_no_warn]
----
 /* @PersistenceContext
    private EntityManager em;

    @Produces
    @UserDatabase
    public EntityManager create() {
        return em;
    } */

    public void close(@Disposes @UserDatabase EntityManager em) {
        em.close();
    }
----

You can remove the comment indicators from this code and place them
around the field declaration to test how the methods work. The behavior
of the application is the same with either mechanism.

The advantage of producing the `EntityManager` in a separate class
rather than simply injecting it into an enterprise bean is that the
object can easily be reused in a typesafe way. Also, a more complex
application can create multiple entity managers using multiple
persistence units, and this mechanism isolates this code for easy
maintenance, as in the following example:

[source,oac_no_warn]
----
@Singleton
public class JPAResourceProducer {
    @Produces
    @PersistenceUnit(unitName="pu3")
    @TestDatabase
    EntityManagerFactory customerDatabasePersistenceUnit;

    @Produces
    @PersistenceContext(unitName="pu3")
    @TestDatabase
    EntityManager customerDatabasePersistenceContext;

    @Produces
    @PersistenceUnit(unitName="pu4")
    @Documents
    EntityManagerFactory customerDatabasePersistenceUnit;

    @Produces
    @PersistenceContext(unitName="pu4")
    @Documents
    EntityManager docDatabaseEntityManager;"
}
----

The `EntityManagerFactory` declarations also allow applications to use
an application-managed entity manager.

[[GKHPD]]

[[the-producerfields-entity-and-session-bean]]
The producerfields Entity and Session Bean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `producerfields` example contains a simple entity class,
`entity.ToDo`, and a stateful session bean, `ejb.RequestBean`, that uses
it.

The entity class contains three fields: an autogenerated `id` field, a
string specifying the task, and a timestamp. The timestamp field,
`timeCreated`, is annotated with `@Temporal`, which is required for
persistent `Date` fields.

[source,oac_no_warn]
----
@Entity
public class ToDo implements Serializable {

    ...
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    protected String taskText;
    @Temporal(TIMESTAMP)
    protected Date timeCreated;

    public ToDo() {
    }

    public ToDo(Long id, String taskText, Date timeCreated) {
        this.id = id;
        this.taskText = taskText;
        this.timeCreated = timeCreated;
    }
    ...
----

The remainder of the `ToDo` class contains the usual getters, setters,
and other entity methods.

The `RequestBean` class injects the `EntityManager` generated by the
producer method, annotated with the `@UserDatabase` qualifier:

[source,oac_no_warn]
----
@ConversationScoped
@Stateful
public class RequestBean {

    @Inject
    @UserDatabase
    EntityManager em;
----

It then defines two methods, one that creates and persists a single
`ToDo` list item, and another that retrieves all the `ToDo` items
created so far by creating a query:

[source,oac_no_warn]
----
    public ToDo createToDo(String inputString) {
        ToDo toDo = null;
        Date currentTime = Calendar.getInstance().getTime();

        try {
            toDo = new ToDo();
            toDo.setTaskText(inputString);
            toDo.setTimeCreated(currentTime);
            em.persist(toDo);
            return toDo;
        } catch (Exception e) {
            throw new EJBException(e.getMessage());
        }
    }

    public List<ToDo> getToDos() {
        try {
             List<ToDo> toDos =
                    (List<ToDo>) em.createQuery(
                    "SELECT t FROM ToDo t ORDER BY t.timeCreated")
                    .getResultList();
            return toDos;
        } catch (Exception e) {
            throw new EJBException(e.getMessage());
        }
    }
}
----

[[GKHPF]]

[[the-producerfields-facelets-pages-and-managed-bean]]
The producerfields Facelets Pages and Managed Bean
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The `producerfields` example has two Facelets pages, `index.xhtml` and
`todolist.xhtml`. The simple form on the `index.xhtml` page asks the
user only for the task. When the user clicks the Submit button, the
`listBean.createTask` method is called. When the user clicks the Show
Items button, the action specifies that the `todolist.xhtml` file should
be displayed:

[source,oac_no_warn]
----
    <h:body>
        <h2>To Do List</h2>
        <p>Enter a task to be completed.</p>
        <h:form id="todolist">
            <p><h:outputLabel value="Enter a string: " for="inputString"/>
                <h:inputText id="inputString"
                             value="#{listBean.inputString}"/></p>
            <p><h:commandButton value="Submit"
                                action="#{listBean.createTask()}"/></p>
            <p><h:commandButton value="Show Items"
                                action="todolist"/></p>
        </h:form>
        ...
    </h:body>
----

The managed bean, `web.ListBean`, injects the `ejb.RequestBean` session
bean. It declares the `entity.ToDo` entity and a list of the entity
along with the input string that it passes to the session bean. The
`inputString` is annotated with the `@NotNull` Bean Validation
constraint, so an attempt to submit an empty string results in an error.

[source,oac_no_warn]
----
@Named
@ConversationScoped
public class ListBean implements Serializable {

    ...
    @EJB
    private RequestBean request;
    @NotNull
    private String inputString;
    private ToDo toDo;
    private List<ToDo> toDos;
----

The `createTask` method called by the Submit button calls the
`createToDo` method of `RequestBean`:

[source,oac_no_warn]
----
    public void createTask() {
        this.toDo = request.createToDo(inputString);
    }
----

The `getToDos` method, which is called by the `todolist.xhtml` page,
calls the `getToDos` method of `RequestBean`:

[source,oac_no_warn]
----
public List<ToDo> getToDos() {
        return request.getToDos();
    }
----

To force the Facelets page to recognize an empty string as a null value
and return an error, the `web.xml` file sets the context parameter
`javax.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL` to `true`:

[source,oac_no_warn]
----
<context-param>
  <param-name>javax.faces.INTERPRET_EMPTY_STRING_SUBMITTED_VALUES_AS_NULL</param-name>
  <param-value>true</param-value>
</context-param>
----

The `todolist.xhtml` page is a little more complicated than the
`index.html` page. It contains a `dataTable` element that displays the
contents of the `ToDo` list. The body of the page looks like this:

[source,oac_no_warn]
----
    <body>
        <h2>To Do List</h2>
        <h:form id="showlist">
            <h:dataTable var="toDo"
                         value="#{listBean.toDos}"
                         rules="all"
                         border="1"
                         cellpadding="5">
                <h:column>
                    <f:facet name="header">
                        <h:outputText value="Time Stamp" />
                    </f:facet>
                    <h:outputText value="#{toDo.timeCreated}" />
                </h:column>
                <h:column>
                    <f:facet name="header">
                        <h:outputText value="Task" />
                    </f:facet>
                    <h:outputText value="#{toDo.taskText}" />
                </h:column>
            </h:dataTable>
            <p><h:commandButton id="back" value="Back" action="index" /></p>
        </h:form>
    </body>
----

The value of the `dataTable` is `listBean.toDos`, the list returned by
the managed bean's `getToDos` method, which in turn calls the session
bean's `getToDos` method. Each row of the table displays the
`timeCreated` and `taskText` fields of the individual task. Finally, a
Back button returns the user to the `index.xhtml` page.

[[GKHRH]]

[[running-the-producerfields-example]]
Running the producerfields Example
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

You can use either NetBeans IDE or Maven to build, package, deploy, and
run the `producerfields` application.

The following topics are addressed here:

* link:#GKHPB[To Build, Package, and Deploy the producerfields Example
Using NetBeans IDE]
* link:#GKHRM[To Build, Package, and Deploy the producerfields Example
Using Maven]
* link:#GKHRR[To Run the producerfields Example]

[[GKHPB]]

[[to-build-package-and-deploy-the-producerfields-example-using-netbeans-ide]]
To Build, Package, and Deploy the producerfields Example Using NetBeans IDE
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1.  Make sure that GlassFish Server has been started (see
link:usingexamples002.html#BNADI[Starting and Stopping GlassFish
Server]).
2.  If the database server is not already running, start it by following
the instructions in link:usingexamples004.html#BNADK[Starting and
Stopping Apache Derby].
3.  From the File menu, choose Open Project.
4.  In the Open Project dialog box, navigate to:
+
[source,oac_no_warn]
----
tut-install/examples/cdi
----
5.  Select the `producerfields` folder.
6.  Click Open Project.
7.  In the Projects tab, right-click the `producerfields` project and
select Build.
+
This command builds and packages the application into a WAR file,
`producerfields.war`, located in the `target` directory, and then
deploys it to GlassFish Server.

[[GKHRM]]

[[to-build-package-and-deploy-the-producerfields-example-using-maven]]
To Build, Package, and Deploy the producerfields Example Using Maven
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1.  Make sure that GlassFish Server has been started (see
link:usingexamples002.html#BNADI[Starting and Stopping GlassFish
Server]).
2.  If the database server is not already running, start it by following
the instructions in link:usingexamples004.html#BNADK[Starting and
Stopping Apache Derby].
3.  In a terminal window, go to:
+
[source,oac_no_warn]
----
tut-install/examples/cdi/producerfields/
----
4.  Enter the following command to deploy the application:
+
[source,oac_no_warn]
----
mvn install
----
+
This command builds and packages the application into a WAR file,
`producerfields.war`, located in the `target` directory, and then
deploys it to GlassFish Server.

[[GKHRR]]

[[to-run-the-producerfields-example]]
To Run the producerfields Example
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

1.  In a web browser, enter the following URL:
+
[source,oac_no_warn]
----
http://localhost:8080/producerfields
----
2.  On the Create To Do List page, enter a string in the field and click
Submit.
+
You can enter additional strings and click Submit to create a task list
with multiple items.
3.  Click Show Items.
+
The To Do List page opens, showing the timestamp and text for each item
you created.
4.  Click Back to return to the Create To Do List page.
+
On this page, you can enter more items in the list.
